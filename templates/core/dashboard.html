{% extends "base.html" %}

{% block header_left %}
    {% if projects %}
        <select id="project-select" class="form-select form-select-sm bg-dark text-light border-secondary" style="min-width:220px;">
            {% for project in projects %}
                <option value="{{ project.id }}" data-slug="{{ project.slug }}" {% if current_project and project.id == current_project.id %}selected{% endif %}>
                    {{ project.name }}
                </option>
            {% endfor %}
        </select>
    {% else %}
        <span class="text-secondary small">Нет проектов</span>
    {% endif %}
{% endblock %}

{% block content %}
<style>
    .attachment-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    .attachment-chip {
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.3);
        color: #e5e7eb;
        border-radius: 999px;
        padding: 0.15rem 0.6rem;
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }
    .attachment-chip button {
        border: none;
        background: transparent;
        color: inherit;
        font-size: 0.9rem;
        cursor: pointer;
        line-height: 1;
    }
    .chat-attachments {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    .chat-attachment-preview {
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 0.5rem;
        padding: 0.3rem;
        background: rgba(15, 23, 42, 0.4);
    }
    .chat-attachment-preview img {
        max-width: 180px;
        border-radius: 0.35rem;
        display: block;
    }
</style>
<div class="cc-chat-layout">
    <div class="cc-column" data-col="left">
        <section class="cc-panel"
                 id="agents-panel"
                 data-current-project-id="{% if current_project %}{{ current_project.id }}{% endif %}"
                 data-current-project-slug="{% if current_project %}{{ current_project.slug }}{% endif %}"
                 data-initial-agent-id="{% if initial_agent %}{{ initial_agent.id }}{% endif %}">
            <div class="d-flex flex-wrap justify-content-between align-items-center gap-2 mb-3">
                <div>
                    <div class="fw-semibold">Агенты</div>
                    {% if current_project %}
                        <small class="text-light text-opacity-75">{{ current_project.name }}</small>
                    {% endif %}
                </div>
                <span class="badge bg-info text-dark">{{ agents|length }} активных</span>
            </div>
            <div>
                <div id="agents-list" class="agent-list">
                    {% for agent in agents %}
                        <button type="button"
                                class="agent-item"
                                data-agent-id="{{ agent.id }}"
                                data-agent-name="{{ agent.name }}"
                                data-is-primary="{% if agent.is_primary %}1{% else %}0{% endif %}">
                            <span class="fw-semibold">{{ agent.name }}</span>
                            <span class="badge {% if agent.is_primary %}bg-success{% else %}bg-secondary text-light{% endif %}">
                                {% if agent.project_id %}локальный{% else %}глобальный{% endif %}
                            </span>
                        </button>
                    {% empty %}
                        <div class="text-secondary small">Нет доступных агентов</div>
                    {% endfor %}
                </div>
                <div class="mt-3">
                    <div class="fw-semibold mb-2">LLM Registry</div>
                    <div class="text-secondary small">Primary chat model: <span class="text-light">{{ llm_chat_primary|default:"—" }}</span></div>
                    <div class="text-secondary small">Default embedding model: <span class="text-light">{{ llm_embedding_default|default:"—" }}</span></div>
                    <button type="button" id="llm-sync-button" class="btn btn-outline-info btn-sm text-dark mt-2 w-100">Sync from OpenAI</button>
                    <div id="llm-sync-status" class="small text-secondary mt-2"></div>
                </div>
            </div>
        </section>
    </div>

    <div class="cc-column" data-col="center">
        <section class="cc-panel" id="chat-panel">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div class="fw-semibold">Диалог с агентом</div>
                <div class="d-flex align-items-center gap-2">
                    <div class="text-secondary small" id="chat-agent-name">Выберите агента</div>
                    <button type="button"
                            id="chat-reset-button"
                            class="btn btn-outline-secondary btn-sm text-light border-secondary-subtle"
                            disabled>
                        Новый диалог
                    </button>
                </div>
            </div>
            <div id="chat-messages" class="chat-thread rounded-4 border border-secondary-subtle bg-dark bg-opacity-75 p-3">
                <div class="text-secondary small">Выберите агента слева и начните диалог.</div>
            </div>
            <div id="chat-status" class="text-secondary small mt-2">
                {% if current_project %}
                    Готов к диалогу. Сообщения увидит выбранный агент.
                {% else %}
                    Сначала выберите проект вверху.
                {% endif %}
            </div>
            <form id="chat-form" class="chat-input-bar mt-3">
                <textarea id="chat-input"
                          class="form-control bg-dark text-light border-secondary"
                          rows="3"
                          placeholder="Напишите сообщение..."></textarea>
                <div class="d-flex align-items-center gap-2 mt-2 flex-wrap">
                    <div class="d-flex align-items-center gap-2">
                        <button type="button"
                                id="chat-attach-button"
                                class="btn btn-outline-secondary btn-sm text-light border-secondary-subtle">
                            Прикрепить файл
                        </button>
                        <input type="file" id="chat-file-input" class="d-none" multiple>
                    </div>
                    <div id="chat-attachment-hint" class="text-secondary small flex-grow-1">Можно приложить изображения или документы.</div>
                </div>
                <div id="chat-attachment-list" class="attachment-list mt-2"></div>
                <div class="d-flex align-items-center justify-content-between mt-2">
                    <span class="text-secondary small">Shift+Enter — новая строка</span>
                    <button type="submit" class="btn btn-chat">Отправить</button>
                </div>
            </form>
        </section>
    </div>

    <div class="cc-column" data-col="right">
        <section class="cc-panel" id="agent-tools-panel" style="display:none;">
            <div class="fw-semibold mb-2">
                <span class="fw-semibold">Серверы</span>
            </div>
            <div id="agent-tools-content">
                Загрузите агента, чтобы управлять доступом к инструментам.
            </div>
        </section>

        <section class="cc-panel" id="side-panel">
            <div class="fw-semibold mb-2">
                <span class="fw-semibold">MCP и пайплайны</span>
            </div>
            <div class="small">
                <div class="mb-3">
                    <div class="fw-semibold mb-1">Пайплайны</div>
                    <ul class="list-group list-group-flush">
                        {% for pipeline in pipelines %}
                            <li class="list-group-item bg-dark text-light d-flex justify-content-between align-items-center">
                                <span>{{ pipeline.name }}</span>
                                <span class="text-secondary small">{{ pipeline.owner_agent.name }}</span>
                            </li>
                        {% empty %}
                            <li class="list-group-item bg-dark text-secondary">Нет пайплайнов для проекта</li>
                        {% endfor %}
                    </ul>
                </div>
            </div>
        </section>
    </div>
</div>

<div class="modal fade" id="traceModal" tabindex="-1" aria-labelledby="traceModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content bg-dark text-light border border-secondary">
            <div class="modal-header border-secondary">
                <h5 class="modal-title" id="traceModalLabel">Детали инструмента</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Закрыть"></button>
            </div>
            <div class="modal-body" id="traceModalBody"></div>
        </div>
    </div>
{% endblock %}



{% block extra_js %}
<script>
    (function () {
        const projectSelect = document.getElementById("project-select");
        const agentsPanel = document.getElementById("agents-panel");
        const agentsList = document.getElementById("agents-list");
        const chatForm = document.getElementById("chat-form");
        const chatInput = document.getElementById("chat-input");
        const chatMessages = document.getElementById("chat-messages");
        const chatStatus = document.getElementById("chat-status");
        const chatAgentNameEl = document.getElementById("chat-agent-name");
        const chatResetButton = document.getElementById("chat-reset-button");
        const chatFileInput = document.getElementById("chat-file-input");
        const chatAttachButton = document.getElementById("chat-attach-button");
        const chatAttachmentList = document.getElementById("chat-attachment-list");
        const agentToolsPanelEl = document.getElementById("agent-tools-panel");
        const agentToolsContentEl = document.getElementById("agent-tools-content");
        const fsActionsPanel = document.getElementById("fs-actions-panel");
        const fsActionsLog = document.getElementById("fs-actions-log");
        const fsZipForm = document.getElementById("fs-zip-form");
        const fsUnzipForm = document.getElementById("fs-unzip-form");
        const fsReadJsonForm = document.getElementById("fs-read-json-form");
        const fsWriteJsonForm = document.getElementById("fs-write-json-form");
        const fsJsonReadOutput = document.getElementById("fs-json-read-output");

        const llmSyncButton = document.getElementById("llm-sync-button");
        const llmSyncStatus = document.getElementById("llm-sync-status");
        const traceModalEl = document.getElementById("traceModal");
        const traceModalLabel = document.getElementById("traceModalLabel");
        const traceModalBody = document.getElementById("traceModalBody");
        const traceModal = traceModalEl && window.bootstrap && window.bootstrap.Modal
            ? new window.bootstrap.Modal(traceModalEl)
            : null;

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(";").shift();
        }

        function scrollChatToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        if (llmSyncButton) {
            llmSyncButton.addEventListener("click", async () => {
                llmSyncButton.disabled = true;
                if (llmSyncStatus) {
                    llmSyncStatus.textContent = "Запускаю синхронизацию реестра моделей…";
                }
                try {
                    const resp = await fetch("/api/models/registry/sync/", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": getCookie("csrftoken") || "",
                        },
                    });
                    if (!resp.ok) {
                        const txt = await resp.text();
                        throw new Error(txt || "Ошибка запуска синхронизации");
                    }
                    if (llmSyncStatus) {
                        llmSyncStatus.textContent = "Синхронизация запланирована.";
                    }
                } catch (e) {
                    console.error(e);
                    if (llmSyncStatus) {
                        llmSyncStatus.textContent = "Не удалось запланировать синхронизацию.";
                    }
                } finally {
                    llmSyncButton.disabled = false;
                }
            });
        }

        // --- Project selection with localStorage + query param ---
        if (projectSelect) {
            const urlParams = new URLSearchParams(window.location.search);
            const urlProject = urlParams.get("project");
            const storedProject = window.localStorage.getItem("current_project_id");

            if (!urlProject && storedProject) {
                const option = Array.from(projectSelect.options).find(o => o.value === storedProject);
                if (option) {
                    urlParams.set("project", storedProject);
                    window.location.search = urlParams.toString();
                }
            }

            projectSelect.addEventListener("change", () => {
                const value = projectSelect.value;
                if (value) {
                    window.localStorage.setItem("current_project_id", value);
                    const params = new URLSearchParams(window.location.search);
                    params.set("project", value);
                    window.location.search = params.toString();
                }
            });
        }

        let currentProjectId = agentsPanel ? agentsPanel.dataset.currentProjectId || null : null;
        let currentProjectSlug = agentsPanel ? agentsPanel.dataset.currentProjectSlug || null : null;
        let currentAgentId = agentsPanel ? agentsPanel.dataset.initialAgentId || null : null;
        let currentConversationId = null;
        let filesystemToolMap = {};
        let fsFormsInitialized = false;
        const conversationCache = new Map();
        let pendingAttachments = [];


        function resetAgentToolPanels() {
            filesystemToolMap = {};
            if (agentToolsPanelEl && agentToolsContentEl) {
                agentToolsPanelEl.style.display = "none";
                agentToolsContentEl.innerHTML = "Загрузите агента, чтобы увидеть доступные инструменты.";
            }
            if (fsActionsPanel) {
                fsActionsPanel.style.display = "none";
            }
        }

        resetAgentToolPanels();
        renderPendingAttachments();

        if (chatAttachButton && chatFileInput) {
            chatAttachButton.addEventListener("click", () => chatFileInput.click());
            chatFileInput.addEventListener("change", () => {
                pendingAttachments = Array.from(chatFileInput.files || []);
                renderPendingAttachments();
            });
        }

        function updateResetButtonState() {
            if (!chatResetButton) return;
            const disabled = !currentAgentId || !currentConversationId;
            chatResetButton.disabled = disabled;
        }

        function renderConversation(messages) {
            if (!chatMessages) return;
            chatMessages.innerHTML = "";
            if (!Array.isArray(messages) || !messages.length) {
                const empty = document.createElement("div");
                empty.className = "text-secondary small";
                empty.textContent = "Диалог пока пуст. Напишите первое сообщение.";
                chatMessages.appendChild(empty);
                scrollChatToBottom();
                return;
            }
            appendMessages(messages);
        }

        function storeConversation(agentId, conversationId, messages) {
            const key = String(agentId);
            conversationCache.set(key, {
                id: conversationId,
                messages: Array.isArray(messages) ? messages.slice() : [],
            });
        }

        function appendToConversation(agentId, conversationId, messages) {
            const key = String(agentId);
            const existing = conversationCache.get(key) || { id: conversationId, messages: [] };
            existing.id = conversationId;
            if (Array.isArray(messages) && messages.length) {
                existing.messages = existing.messages.concat(messages);
            }
            conversationCache.set(key, existing);
        }

        
        function escapeHtml(str) {
            return (str ?? "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function formatFileSize(bytes) {
            if (!bytes && bytes !== 0) return "";
            const units = ["Б", "КБ", "МБ", "ГБ"];
            let size = bytes;
            let unit = 0;
            while (size >= 1024 && unit < units.length - 1) {
                size /= 1024;
                unit += 1;
            }
            const formatted = unit === 0 ? size : size.toFixed(1);
            return `${formatted} ${units[unit]}`;
        }

        function renderPendingAttachments() {
            if (!chatAttachmentList) return;
            chatAttachmentList.innerHTML = "";
            if (!pendingAttachments.length) {
                chatAttachmentList.style.display = "none";
                return;
            }
            chatAttachmentList.style.display = "flex";
            pendingAttachments.forEach((file, index) => {
                const chip = document.createElement("div");
                chip.className = "attachment-chip";
                chip.textContent = `${file.name} (${formatFileSize(file.size)})`;
                const removeBtn = document.createElement("button");
                removeBtn.type = "button";
                removeBtn.innerHTML = "&times;";
                removeBtn.addEventListener("click", () => {
                    pendingAttachments.splice(index, 1);
                    renderPendingAttachments();
                    if (chatFileInput && !pendingAttachments.length) {
                        chatFileInput.value = "";
                    }
                });
                chip.appendChild(removeBtn);
                chatAttachmentList.appendChild(chip);
            });
        }

        function resetAttachments() {
            pendingAttachments = [];
            if (chatFileInput) {
                chatFileInput.value = "";
            }
            renderPendingAttachments();
        }

        function createDetailPill(label, count, html) {
            if (!traceModal || !traceModalBody || !traceModalLabel) {
                return null;
            }
            const pill = document.createElement("button");
            pill.type = "button";
            pill.className = "trace-pill";
            pill.textContent = `${label} (${count})`;
            pill.addEventListener("click", () => {
                traceModalLabel.textContent = label;
                traceModalBody.innerHTML = html;
                traceModal.show();
            });
            return pill;
        }

        function buildMemoryHTML(memories) {
            if (!Array.isArray(memories) || !memories.length) {
                return "";
            }
            const parts = ['<div class="trace-section">'];
            memories.forEach((mem) => {
                parts.push('<div class="mb-3">');
                parts.push(`<div>${escapeHtml(mem.content || "")}</div>`);
                const meta = [];
                if (mem.importance) meta.push(`importance: ${escapeHtml(mem.importance)}`);
                if (typeof mem.distance === "number") meta.push(`distance: ${mem.distance.toFixed(3)}`);
                if (mem.created_at) meta.push(`created_at: ${escapeHtml(mem.created_at)}`);
                if (meta.length) {
                    parts.push(`<div class="text-secondary small">${meta.join(" · ")}</div>`);
                }
                parts.push("</div>");
            });
            parts.push("</div>");
            return parts.join("");
        }

        function buildToolTracesHTML(traces) {
            if (!Array.isArray(traces) || !traces.length) {
                return "";
            }
            const parts = ['<div class="trace-section">'];
            traces.forEach((trace) => {
                const fn = trace.function || "";
                const payload = trace.payload || {};
                if (
                    fn === "memory_recall" &&
                    Array.isArray(payload.memories) &&
                    payload.memories.length
                ) {
                    parts.push('<div class="mb-3"><div class="text-info">• memory_recall — выборка воспоминаний</div>');
                    payload.memories.forEach((mem) => {
                        parts.push('<div class="mt-2"><div>' + escapeHtml(mem.content || "") + "</div>");
                        const meta = [];
                        if (mem.importance) meta.push(`importance: ${escapeHtml(mem.importance)}`);
                        if (typeof mem.distance === "number") meta.push(`distance: ${mem.distance.toFixed(3)}`);
                        if (meta.length) {
                            parts.push(`<div class="text-secondary small">${meta.join(" · ")}</div>`);
                        }
                        parts.push("</div>");
                    });
                    parts.push("</div>");
                    return;
                }
                if (
                    fn === "graph_recall" &&
                    Array.isArray(payload.nodes) &&
                    payload.nodes.length
                ) {
                    parts.push('<div class="mb-3"><div class="text-info">• graph_recall — найденные узлы</div><ul class="ps-3">');
                    payload.nodes.forEach((node) => {
                        parts.push(
                            `<li class="mb-1"><strong>${escapeHtml(node.label || "")}</strong> <span class="text-secondary">(${escapeHtml(
                                node.type || "",
                            )})</span></li>`,
                        );
                    });
                    parts.push("</ul></div>");
                    return;
                }
                if (
                    fn === "rag_recall" &&
                    Array.isArray(payload.documents) &&
                    payload.documents.length
                ) {
                    parts.push('<div class="mb-3"><div class="text-info">• rag_recall — документы</div><ul class="ps-3">');
                    payload.documents.forEach((doc) => {
                        parts.push(`<li class="mb-1"><strong>${escapeHtml(doc.title || doc.path || "Документ")}</strong></li>`);
                    });
                    parts.push("</ul></div>");
                    return;
                }
                parts.push('<div class="mb-3">');
                parts.push(`<div class="text-info">• ${escapeHtml(fn || "tool_call")}</div>`);
                parts.push(
                    `<pre class="bg-dark text-light border border-secondary rounded-3 p-2 small mt-2">${escapeHtml(
                        JSON.stringify(payload, null, 2),
                    )}</pre>`,
                );
                parts.push("</div>");
            });
            parts.push("</div>");
            return parts.join("");
        }

        function createAttachmentPreview(attachment) {
            const wrapper = document.createElement("div");
            wrapper.className = "chat-attachment-preview";
            const name = attachment.original_name || "Файл";
            const sizeLabel = formatFileSize(attachment.size);
            if (attachment.is_image) {
                const link = document.createElement("a");
                link.href = attachment.url;
                link.target = "_blank";
                link.rel = "noreferrer";
                const img = document.createElement("img");
                img.src = attachment.url;
                img.alt = name;
                link.appendChild(img);
                wrapper.appendChild(link);
                const caption = document.createElement("div");
                caption.className = "text-secondary small mt-1";
                caption.textContent = `${name}${sizeLabel ? ` (${sizeLabel})` : ""}`;
                wrapper.appendChild(caption);
            } else {
                const link = document.createElement("a");
                link.href = attachment.url;
                link.target = "_blank";
                link.rel = "noreferrer";
                link.textContent = name;
                wrapper.appendChild(link);
                if (sizeLabel) {
                    const meta = document.createElement("div");
                    meta.className = "text-secondary small";
                    meta.textContent = sizeLabel;
                    wrapper.appendChild(meta);
                }
            }
            return wrapper;
        }


        function pushFsLog(title, payload, isError = false) {
            if (!fsActionsLog) return;
            const wrapper = document.createElement("div");
            wrapper.style.marginBottom = "0.5rem";
            const header = document.createElement("div");
            header.style.fontSize = "0.8rem";
            header.style.fontWeight = "600";
            header.style.color = isError ? "#fca5a5" : "#a5b4fc";
            header.textContent = title;
            const pre = document.createElement("pre");
            pre.style.whiteSpace = "pre-wrap";
            pre.style.fontSize = "0.75rem";
            pre.style.marginTop = "0.2rem";
            pre.textContent =
                typeof payload === "string" ? payload : JSON.stringify(payload, null, 2);
            wrapper.appendChild(header);
            wrapper.appendChild(pre);
            fsActionsLog.prepend(wrapper);
        }

        async function invokeFilesystemTool(toolName, args) {
            const toolId = filesystemToolMap[toolName];
            if (!toolId) {
                throw new Error(`Инструмент ${toolName} недоступен для текущего агента.`);
            }
            const resp = await fetch(`/api/mcp/tools/${toolId}/invoke/`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": getCookie("csrftoken") || "",
                },
                body: JSON.stringify({ arguments: args }),
            });
            const data = await resp.json();
            if (!resp.ok || data.error) {
                throw new Error(data.error?.message || "Ошибка вызова инструмента");
            }
            const result =
                data.result?.structuredContent?.result ||
                data.result?.structuredContent ||
                data.result ||
                data;
            return result;
        }

        function initFsActionForms() {
            if (fsFormsInitialized) return;
            fsFormsInitialized = true;

            if (fsZipForm) {
                fsZipForm.addEventListener("submit", async (event) => {
                    event.preventDefault();
                    const entriesField = document.getElementById("fs-zip-entries");
                    const archiveField = document.getElementById("fs-zip-archive");
                    const overwriteField = document.getElementById("fs-zip-overwrite");
                    try {
                        const entries = (entriesField.value || "")
                            .split("\n")
                            .map((v) => v.trim())
                            .filter(Boolean);
                        if (!entries.length) {
                            throw new Error("Укажите хотя бы один путь для архивации.");
                        }
                        const archive = archiveField.value.trim();
                        if (!archive) {
                            throw new Error("Введите путь для архива.");
                        }
                        const result = await invokeFilesystemTool("fs_zip", {
                            entries,
                            archive_path: archive,
                            overwrite: !!overwriteField.checked,
                        });
                        pushFsLog("fs_zip", result);
                    } catch (err) {
                        pushFsLog("fs_zip — ошибка", err.message || err, true);
                    }
                });
            }

            if (fsUnzipForm) {
                fsUnzipForm.addEventListener("submit", async (event) => {
                    event.preventDefault();
                    const archiveField = document.getElementById("fs-unzip-archive");
                    const destField = document.getElementById("fs-unzip-dest");
                    const overwriteField = document.getElementById("fs-unzip-overwrite");
                    try {
                        const archive = archiveField.value.trim();
                        const dest = destField.value.trim();
                        if (!archive || !dest) {
                            throw new Error("Укажите и архив, и каталог назначения.");
                        }
                        const result = await invokeFilesystemTool("fs_unzip", {
                            archive_path: archive,
                            dest_path: dest,
                            overwrite: !!overwriteField.checked,
                        });
                        pushFsLog("fs_unzip", result);
                    } catch (err) {
                        pushFsLog("fs_unzip — ошибка", err.message || err, true);
                    }
                });
            }

            if (fsReadJsonForm) {
                fsReadJsonForm.addEventListener("submit", async (event) => {
                    event.preventDefault();
                    const pathField = document.getElementById("fs-json-read-path");
                    try {
                        const path = pathField.value.trim();
                        if (!path) throw new Error("Укажите путь к файлу.");
                        const result = await invokeFilesystemTool("fs_read_json", { path });
                        if (fsJsonReadOutput) {
                            fsJsonReadOutput.textContent = JSON.stringify(result.data, null, 2);
                        }
                        pushFsLog("fs_read_json", result);
                    } catch (err) {
                        if (fsJsonReadOutput) fsJsonReadOutput.textContent = "";
                        pushFsLog("fs_read_json — ошибка", err.message || err, true);
                    }
                });
            }

            if (fsWriteJsonForm) {
                fsWriteJsonForm.addEventListener("submit", async (event) => {
                    event.preventDefault();
                    const pathField = document.getElementById("fs-json-write-path");
                    const dataField = document.getElementById("fs-json-write-data");
                    const overwriteField = document.getElementById("fs-json-write-overwrite");
                    try {
                        const path = pathField.value.trim();
                        if (!path) throw new Error("Укажите путь для записи.");
                        let parsed;
                        try {
                            parsed = JSON.parse(dataField.value);
                        } catch (jsonErr) {
                            throw new Error("Некорректный JSON: " + jsonErr.message);
                        }
                        const result = await invokeFilesystemTool("fs_write_json", {
                            path,
                            data: parsed,
                            overwrite: !!overwriteField.checked,
                        });
                        pushFsLog("fs_write_json", result);
                    } catch (err) {
                        pushFsLog("fs_write_json — ошибка", err.message || err, true);
                    }
                });
            }
        }

        initFsActionForms();

        async function loadAgentDetails(agentId) {
            if (!agentId) {
                resetAgentToolPanels();
                return;
            }
            resetAgentToolPanels();
            try {
                await loadAgentMcpAccess(agentId);
            } catch (e) {
                console.error(e);
                resetAgentToolPanels();
            }
        }

        async function loadConversationForAgent(agentId, options = {}) {
            const { forceReload = false } = options;
            if (!agentId || !currentProjectId) {
                updateResetButtonState();
                return;
            }
            const cacheKey = String(agentId);
            const cached = conversationCache.get(cacheKey);
            if (cached && !forceReload) {
                currentConversationId = cached.id || null;
                renderConversation(cached.messages || []);
                chatStatus.textContent =
                    cached.messages && cached.messages.length
                        ? "Продолжаем диалог."
                        : "Диалог пока пуст. Напишите первое сообщение.";
            } else if (!cached) {
                chatMessages.innerHTML =
                    '<div class="text-secondary small">Загружаю переписку…</div>';
            }

            try {
                const resp = await fetch(
                    `/api/projects/${currentProjectId}/assistant/conversation/?agent_id=${agentId}`,
                );
                if (!resp.ok) {
                    const txt = await resp.text();
                    throw new Error(txt || "Не удалось загрузить диалог.");
                }
                const data = await resp.json();
                currentConversationId = data.id;
                storeConversation(agentId, data.id, data.messages || []);
                renderConversation(data.messages || []);
                chatStatus.textContent =
                    Array.isArray(data.messages) && data.messages.length
                        ? "Продолжаем диалог."
                        : "Диалог создан. Напишите первое сообщение.";
            } catch (err) {
                console.error(err);
                if (!cached) {
                    chatMessages.innerHTML = `<div class="text-danger small">${escapeHtml(
                        err.message || "Не удалось загрузить диалог.",
                    )}</div>`;
                }
                chatStatus.textContent = "Ошибка загрузки диалога.";
            } finally {
                updateResetButtonState();
            }
        }
        async function loadAgentMcpAccess(agentId) {
            if (!agentToolsPanelEl || !agentToolsContentEl) return;
            agentToolsPanelEl.style.display = "block";
            agentToolsContentEl.textContent = "Загрузка...";
            filesystemToolMap = {};
            if (fsActionsPanel) {
                fsActionsPanel.style.display = "none";
            }
            try {
                const resp = await fetch(`/api/agents/${agentId}/mcp-access/`);
                if (!resp.ok) {
                    const txt = await resp.text();
                    throw new Error(txt || "Не удалось получить доступы.");
                }
                const data = await resp.json();
                renderAgentMcpAccess(data);
            } catch (err) {
                console.error(err);
                agentToolsContentEl.innerHTML =
                    `<div style="color:#fca5a5;">${err.message || err}</div>`;
                if (fsActionsPanel) {
                    fsActionsPanel.style.display = "none";
                }
            }
        }

        function renderAgentMcpAccess(payload) {
            if (!agentToolsPanelEl || !agentToolsContentEl) return;
            const bindings = payload.bindings || [];
            if (!bindings.length) {
                agentToolsContentEl.innerHTML =
                    "<div style='color:#9ca3af;'>У агента нет привязанных MCP-серверов.</div>";
                agentToolsPanelEl.style.display = "block";
                if (fsActionsPanel) fsActionsPanel.style.display = "none";
                filesystemToolMap = {};
                return;
            }
            agentToolsPanelEl.style.display = "block";
            agentToolsContentEl.innerHTML = "";

            let hasFilesystem = false;

            bindings.forEach((binding) => {
                const accordion = document.createElement("div");
                accordion.className = "mcp-accordion";

                const toggle = document.createElement("button");
                toggle.type = "button";
                toggle.className = "mcp-accordion-toggle";
                toggle.innerHTML = `<div>${binding.server.name}</div><span>${(binding.tools || []).length} инструментов</span>`;
                accordion.appendChild(toggle);

                const body = document.createElement("div");
                body.className = "mcp-accordion-body";
                const stateKey = `mcpAccordion:${binding.server.id}`;
                let isOpen = false;
                try {
                    isOpen = window.localStorage.getItem(stateKey) === "open";
                } catch (storageErr) {}
                if (isOpen) {
                    body.style.display = "block";
                    toggle.classList.add("open");
                } else {
                    body.style.display = "none";
                }
                toggle.addEventListener("click", () => {
                    const currentlyOpen = body.style.display === "block";
                    const nextState = !currentlyOpen;
                    body.style.display = nextState ? "block" : "none";
                    toggle.classList.toggle("open", nextState);
                    try {
                        window.localStorage.setItem(stateKey, nextState ? "open" : "closed");
                    } catch (storageErr) {}
                });

                const allowAllWrapper = document.createElement("label");
                allowAllWrapper.style.display = "flex";
                allowAllWrapper.style.alignItems = "center";
                allowAllWrapper.style.gap = "0.35rem";
                allowAllWrapper.style.fontSize = "0.8rem";
                allowAllWrapper.style.color = "#e5e7eb";
                const allowAllInput = document.createElement("input");
                allowAllInput.type = "checkbox";
                allowAllInput.checked = !!binding.all_allowed;
                allowAllWrapper.appendChild(allowAllInput);
                allowAllWrapper.appendChild(
                    document.createTextNode("Все инструменты (без ограничений)")
                );
                body.appendChild(allowAllWrapper);

                const list = document.createElement("div");
                list.className = "mcp-tool-grid";

                const toolCheckboxes = [];
                (binding.tools || []).forEach((tool) => {
                    const item = document.createElement("label");
                    item.style.display = "flex";
                    item.style.alignItems = "center";
                    item.style.gap = "0.35rem";
                    item.style.fontSize = "0.75rem";
                    item.style.color = "#e5e7eb";
                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.value = tool.id;
                    checkbox.checked =
                        binding.all_allowed ||
                        (binding.allowed_tool_ids || []).includes(tool.id);
                    item.appendChild(checkbox);
                    item.appendChild(document.createTextNode(tool.name));
                    if (tool.description) {
                        item.title = tool.description;
                    }
                    list.appendChild(item);
                    toolCheckboxes.push(checkbox);
                });

                body.appendChild(list);

                const buttonsRow = document.createElement("div");
                buttonsRow.style.display = "flex";
                buttonsRow.style.alignItems = "center";
                buttonsRow.style.gap = "0.5rem";

                const saveBtn = document.createElement("button");
                saveBtn.textContent = "Сохранить доступ";
                saveBtn.style.background = "#2563eb";
                saveBtn.style.border = "none";
                saveBtn.style.color = "#e5e7eb";
                saveBtn.style.borderRadius = "0.375rem";
                saveBtn.style.padding = "0.35rem 0.7rem";
                saveBtn.style.fontSize = "0.8rem";
                saveBtn.style.cursor = "pointer";

                const status = document.createElement("div");
                status.style.fontSize = "0.75rem";
                status.style.color = "#9ca3af";

                buttonsRow.appendChild(saveBtn);
                buttonsRow.appendChild(status);
                body.appendChild(buttonsRow);

                const updateCheckboxState = () => {
                    const disabled = allowAllInput.checked;
                    toolCheckboxes.forEach((box) => {
                        box.disabled = disabled;
                    });
                };
                updateCheckboxState();
                allowAllInput.addEventListener("change", updateCheckboxState);

                saveBtn.addEventListener("click", async () => {
                    status.textContent = "Сохранение…";
                    saveBtn.disabled = true;
                    try {
                        const payload = {
                            server_id: binding.server.id,
                            allowed_tool_ids: allowAllInput.checked
                                ? []
                                : toolCheckboxes
                                      .filter((box) => box.checked)
                                      .map((box) => Number(box.value)),
                        };
                        const resp = await fetch(`/api/agents/${currentAgentId}/mcp-access/`, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "X-CSRFToken": getCookie("csrftoken") || "",
                            },
                            body: JSON.stringify(payload),
                        });
                        if (!resp.ok) {
                            const txt = await resp.text();
                            throw new Error(txt || "Не удалось сохранить");
                        }
                        status.textContent = "Сохранено";
                        if (currentAgentId) {
                            loadAgentMcpAccess(currentAgentId);
                        }
                    } catch (err) {
                        status.textContent = err.message || "Ошибка";
                    } finally {
                        saveBtn.disabled = false;
                    }
                });

                accordion.appendChild(body);
                agentToolsContentEl.appendChild(accordion);

                if (binding.server.name.toLowerCase().includes("filesystem")) {
                    hasFilesystem = true;
                    filesystemToolMap = {};
                    (binding.tools || []).forEach((tool) => {
                        filesystemToolMap[tool.name] = tool.id;
                    });
                }
            });

            if (fsActionsPanel) {
                fsActionsPanel.style.display = hasFilesystem ? "block" : "none";
            }
        }

        function updateAgentsSelection() {
            const buttons = agentsList ? agentsList.querySelectorAll(".agent-item") : [];
            buttons.forEach(btn => {
                const agentId = btn.dataset.agentId;
                if (currentAgentId && agentId === String(currentAgentId)) {
                    btn.classList.add("active");
                } else {
                    btn.classList.remove("active");
                }
            });
            if (chatAgentNameEl) {
                if (currentAgentId) {
                    const currentBtn = agentsList?.querySelector(`.agent-item[data-agent-id="${currentAgentId}"]`);
                    const displayName = currentBtn?.dataset.agentName || currentBtn?.textContent.trim() || "—";
                    chatAgentNameEl.textContent = displayName;
                } else {
                    chatAgentNameEl.textContent = "Выберите агента";
                }
            }
            updateResetButtonState();
        }

        if (agentsList) {
            agentsList.addEventListener("click", (event) => {
                const button = event.target.closest(".agent-item");
                if (!button) return;
                const agentId = button.dataset.agentId;
                if (!agentId) return;
                currentAgentId = agentId;
                currentConversationId = null;
                chatStatus.textContent = "Загружаю диалог...";
                updateAgentsSelection();
                resetAgentToolPanels();
                resetAttachments();
                loadAgentDetails(currentAgentId);
                loadConversationForAgent(currentAgentId);
            });
            if (!currentAgentId) {
                const primary = agentsList.querySelector('.agent-item[data-is-primary="1"]');
                const first = agentsList.querySelector(".agent-item");
                const initial = primary || first;
                if (initial) {
                    currentAgentId = initial.dataset.agentId;
                }
            }
            updateAgentsSelection();
            if (currentAgentId) {
                loadAgentDetails(currentAgentId);
                loadConversationForAgent(currentAgentId);
            }
        }

        function appendMessages(messages) {
            messages.forEach((msg) => {
                const wrapper = document.createElement("div");
                wrapper.className = "mb-3";
                const sender = msg.sender === "user" ? "Вы" : msg.sender === "assistant" ? "Ассистент" : "Система";
                const label = document.createElement("div");
                label.className = "text-secondary small mb-1";
                label.textContent = sender;
                const bubble = document.createElement("div");
                bubble.className = "chat-bubble";
                if (msg.sender === "assistant") {
                    bubble.classList.add("assistant");
                } else if (msg.sender === "user") {
                    bubble.classList.add("user");
                } else {
                    bubble.classList.add("system");
                }
                bubble.textContent = msg.content;
                wrapper.appendChild(label);
                wrapper.appendChild(bubble);

                if (Array.isArray(msg.attachments) && msg.attachments.length) {
                    const attachmentsWrapper = document.createElement("div");
                    attachmentsWrapper.className = "chat-attachments mt-2";
                    msg.attachments.forEach((attachment) => {
                        attachmentsWrapper.appendChild(createAttachmentPreview(attachment));
                    });
                    wrapper.appendChild(attachmentsWrapper);
                }

                const traces = Array.isArray(msg.meta?.tool_traces) ? msg.meta.tool_traces : [];
                const retrievedMemories = Array.isArray(msg.meta?.retrieved_memories)
                    ? msg.meta.retrieved_memories
                    : [];
                const detailPills = document.createElement("div");
                detailPills.className = "d-flex flex-wrap gap-2 mt-2";
                let detailsAdded = false;

                const toolDetails = buildToolTracesHTML(traces);
                if (toolDetails) {
                    const pill = createDetailPill("tool_traces", traces.length, toolDetails);
                    if (pill) {
                        detailPills.appendChild(pill);
                        detailsAdded = true;
                    }
                }

                const memoryDetails = buildMemoryHTML(retrievedMemories);
                if (memoryDetails) {
                    const pill = createDetailPill("Память агента", retrievedMemories.length, memoryDetails);
                    if (pill) {
                        detailPills.appendChild(pill);
                        detailsAdded = true;
                    }
                }

                if (detailsAdded) {
                    wrapper.appendChild(detailPills);
                }

                chatMessages.appendChild(wrapper);
            });
            scrollChatToBottom();
        }

        async function sendAssistantMessage(projectId, agentId, text, conversationId, attachmentsFiles) {
            const hasAttachments = Array.isArray(attachmentsFiles) && attachmentsFiles.length > 0;
            let response;
            if (hasAttachments) {
                const formData = new FormData();
                formData.append("message", text);
                formData.append("agent_id", Number(agentId));
                if (conversationId) {
                    formData.append("conversation_id", conversationId);
                }
                attachmentsFiles.forEach((file) => formData.append("attachments", file));
                response = await fetch(`/api/projects/${projectId}/assistant/chat/`, {
                    method: "POST",
                    body: formData,
                    headers: {
                        "X-CSRFToken": getCookie("csrftoken") || "",
                    },
                });
            } else {
                const payload = {
                    message: text,
                    agent_id: Number(agentId),
                };
                if (conversationId) {
                    payload.conversation_id = conversationId;
                }
                response = await fetch(`/api/projects/${projectId}/assistant/chat/`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCookie("csrftoken") || "",
                    },
                    body: JSON.stringify(payload),
                });
            }
            if (!response.ok) {
                const textErr = await response.text();
                throw new Error(textErr || "Ошибка ответа сервера");
            }
            return response.json();
        }

        if (chatResetButton) {
            chatResetButton.addEventListener("click", async () => {
                if (!currentAgentId || !currentProjectId) {
                    return;
                }
                chatResetButton.disabled = true;
                chatStatus.textContent = "Создаю новый диалог...";
                resetAttachments();
                try {
                    const resp = await fetch(
                        `/api/projects/${currentProjectId}/assistant/conversation/`,
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "X-CSRFToken": getCookie("csrftoken") || "",
                            },
                            body: JSON.stringify({ agent_id: Number(currentAgentId) }),
                        },
                    );
                    if (!resp.ok) {
                        const txt = await resp.text();
                        throw new Error(txt || "Не удалось создать диалог.");
                    }
                    const data = await resp.json();
                    currentConversationId = data.id;
                    storeConversation(currentAgentId, data.id, data.messages || []);
                    renderConversation(data.messages || []);
                    chatStatus.textContent = "Новый диалог создан.";
                } catch (err) {
                    console.error(err);
                    chatStatus.textContent = "Не удалось создать диалог: " + (err.message || err);
                } finally {
                    chatResetButton.disabled = false;
                    updateResetButtonState();
                }
            });
        }

        if (chatForm) {
            chatForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                const text = chatInput.value.trim();
                if (!text && !pendingAttachments.length) return;
                const projectId = agentsPanel ? agentsPanel.dataset.currentProjectId : null;
                if (!projectId) {
                    chatStatus.textContent = "Проект не выбран.";
                    return;
                }
                if (!currentAgentId) {
                    chatStatus.textContent = "Нет выбранного агента.";
                    return;
                }

                const submitButton = chatForm.querySelector("button[type=submit]");
                if (submitButton) {
                    submitButton.disabled = true;
                }
                chatStatus.textContent = "Отправка...";

                try {
                    const data = await sendAssistantMessage(
                        projectId,
                        currentAgentId,
                        text,
                        currentConversationId,
                        pendingAttachments.slice(),
                    );
                    currentConversationId = data.conversation_id;
                    appendMessages(data.messages || []);
                    appendToConversation(currentAgentId, currentConversationId, data.messages || []);
                    chatInput.value = "";
                    resetAttachments();
                    chatStatus.textContent = "";
                    updateResetButtonState();
                } catch (err) {
                    console.error(err);
                    chatStatus.textContent = "Ошибка: " + (err.message || err);
                } finally {
                    if (submitButton) {
                        submitButton.disabled = false;
                    }
                }
            });
        }
    })();
</script>
{% endblock %}
